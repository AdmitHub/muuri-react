## Props {docsify-ignore}

In this `documentation` the props of the MuuriComponent are grouped into two categories in order to clarify their usefulness.

### Interaction props

These are the props to use to `interact` with the functionality of the MuuriComponent.

* [ref](#ref)
* [id](#id)
* [groupIds](#groupIds)
* [gridProps](#gridProps)
* [filter](#filter)
* [sort](#sort)
* [sortOptions](#sortOptions)
* [addOptions](#addOptions)
* [instantLayout](#instantLayout)
* [propsToData](#layoutonresize)
* [onSend](#onSend)
* [onMount](#onMount)
* [onUnmount](#onUnmount)
* [forceSync](#forceSync)

#### ref

The [ref](https://reactjs.org/docs/refs-and-the-dom.html) for the [Muuri](https://github.com/haltu/muuri) instance used inside the MuuriComponent. See more [here](usage/muuri).

* Accepted types: `React.Ref`, `function`.

```js
const muuriRef = useRef()

<MuuriComponent
  ref={muuriRef}
/>
```

```js
<MuuriComponent
  ref={(muuri) => {}}
/>
```

#### id

The id of the MuuriComponent.

* Accepted types: `string`.

```js
<MuuriComponent
  id={"id"}
/>
```

#### groupIds

The ids of the groups to which the MuuriComponent belongs. This option is used [here](#dragsort).

* Accepted types: `string[]`.

```javascript
<MuuriComponent
  groupIds={["GroupA", "GroupB"]}
/>
```

#### gridProps

The props of the DOM element generated by the MuuriComponent.

* Accepted types: `object`.

```js
<MuuriComponent
  gridProps={{ className: 'grid' }}
/>
```

#### filter

The filter function is executed for every item in the instance. If the return value of the predicate is truthy the item in question will be shown and otherwise hidden. The function receives the [data](usage/items-data.md) of the item as it's argument. <br> 
Remember to provide a memoized value to avoid useless re-filtering (as the component will re-filter each time the value change). See more [here](usage/filtering-&-sorting?id=filtering).

* Accepted types: `function`.

```js
const filter = useCallback(itemData => {
  // Show only the items that respect the condition.
  return itemData.someData === 'someValue'
}, [])

<MuuriComponent
  filter={filter}
/>
```

#### sort

There are two ways to sort the items. The first is simply by providing a function as the comparer, which will receive the [data](usage/items-data) of two items to compare as arguments. It works almost identically to native array sort, the only difference is that the sort is always stable. Alternatively you can sort by the [data](usage/items-data) you have provided for the items. Just provide the data key(s) as a string (separated by space) and the items will be sorted based on the provided data keys. <br> 
If you are using a function, remember to provide a memoized value to avoid useless re-sorting (as the component will re-sort each time the value change). See more [here](usage/filtering-&-sorting?id=sorting).


* Accepted types: `string`, `function`.

```js
const sort = useCallback((dataItemA, dataItemB) => {
  // Sort by id.
  return dataItemA.id - dataItemB.id
}, [])

<MuuriComponent
  propsToData={({ id }) => ({ id })}
  sort={sort}
/>
```

```js
<MuuriComponent
  propsToData={({ id, tag }) => ({ id, tag })}
  {/* Sort by id and by tag */}
  sort={"id tag"}
/>
```

```js
<MuuriComponent
  propsToData={({ id, tag }) => ({ id, tag })}
  {/* Sort some keys ascending and some keys descending */}
  sort={"id tag:desc"}
/>
```

#### sortOptions

With this options you can change the sorting order (default ascending). <br> 
Remember to provide a memoized value to avoid useless re-sorting (as the component will re-sort each time the value change).

* Accepted types: `object`.
* Default value: `{ descending: false }`

```js
const [sortOptions] = useState({ descending: true })

<MuuriComponent
  sortOptions={sortOptions}
/>
```

#### addOptions

With this options you can decide how the MuuriComponent will manage the new items added with the CSS display property set to none, If show is true the item will be added with a showing animation, otherwise the item will be hidden. Note that if the filter props is setted it takes precedence over the decision of which items are visible or not.

* Accepted types: `object`.
* Default value: `{ show: true }`

```js
<MuuriComponent
  addOptions={{ show: false }}
/>
```

#### propsToData

The function is executed for each item in the instance. The returned object will represent the data of the item in question. The function receives the props of the item as it's argument. See more [here](usage/items-data)

* Accepted types: `function`.

```js
const items = [{ id: 1 }, { id: 2 }]
const children = items.map(({ id }) => <Item id={id} />)

// The id prop will be used as data.
<MuuriComponent
  propsToData={({ id }) => ({ id })}
>
  {children}
</MuuriComponent>
```

#### onSend

A function called when an item is sended from a MuuriComponent to another, if your project use this functionality then it is mandatory to use this property to synchronize the state of the items with the change. The function will receive the information about the event as it's argument as shown in the example above. See more [here](usage/reparenting).

* Accepted types: `function`.

```js
const [items, setItems] = useState([])

<MuuriComponent
  onSend={({
    // The key the user has set.
    key,
    // The effectivly key of the component
    // that can be different from the provided key
    componentKey,

    // The index of the item in 
    // the old MuuriComponent.
    fromIndex,
    // The id of the old MuuriComponent.
    fromId,
    // The group ids of the old MuuriComponent.
    fromGroupId,
    
    // The index of the item in 
    // the new MuuriComponent.
    toIndex,
    // The id of the new MuuriComponent.
    toId,
    // The group ids of the new MuuriComponent.
    toGroupId,

    // The old Muuri instance.
    fromGrid,
    // The new Muuri instance.
    toGrid
  }) => {
    // Sync the state.
  }}
/>
```

#### onMount

A function that will be called when the component will mount, it receive the muuri instance as argument. See more [here](usage/muuri).

* Accepted types: `function`.

```js
<MuuriComponent
  onMount={muuri => {}}
/>
```

#### onUnmount

A function that will be called when the component will mount, it receive the muuri instance as argument. Note that the first provided function will be called (the one passed when the MuuriComponent is mounted), so be carefull with its variables scope. will See more [here](usage/muuri).

* Accepted types: `function`.

```js
<MuuriComponent
  onUnmount={muuri => {}}
/>
```

#### forceSync

Sorting and filtering are not reapplied with a new rendering if their value does not change. If the prop is true, the MuuriComponent checks in each re-render if there have been changes and reapplies sorting and/or filtering (even if their values ​​have not been changed).

* Accepted types: `boolean`.
* Default value: `false`

```js
<MuuriComponent
  forceSync
/>
```

### Layout props

These are the props that determine how the MuuriComponent will `work`, from enabling drag up to the speed of animations. These props can only be chosen when the component is mounted, modifying them in subsequent renders will have no effect.

#### Default values

The default options are stored in `MuuriComponent.defaultOptions` object, which in it's default state contains the following configuration:

```js
<MuuriComponent
  {/* Default show animation */}
  showDuration={300}
  showEasing={"ease"}

  {/* Default hide animation */}
  hideDuration={300}
  hideEasing={"ease"}

  {/* Item's visible/hidden state styles */}
  visibleStyles={{
    opacity: "1",
    transform: "scale(1)"
  }}
  hiddenStyles={{
    opacity: "0",
    transform: "scale(0.5)"
  }}

  {/* Layout */}
  layout={{
    fillGaps: false,
    horizontal: false,
    alignRight: false,
    alignBottom: false,
    rounding: true
  }}
  layoutOnResize={100}
  layoutOnInit={true}
  layoutDuration={300}
  layoutEasing={"ease"}

  {/* Drag & Drop */}
  dragEnabled={false}
  dragContainer={null}
  dragStartPredicate={{
    distance: 0,
    delay: 0,
    handle: false
  }}
  dragAxis={null}
  dragSort={true}
  dragSortHeuristics={{
    sortInterval: 100,
    minDragDistance: 10,
    minBounceBackAngle: 1
  }}
  dragSortPredicate={{
    threshold: 50,
    action: "move"
  }}
  dragReleaseDuration={300}
  dragReleaseEasing={"ease"}
  dragCssProps={{
    touchAction: "none",
    userSelect: "none",
    userDrag: "none",
    tapHighlightColor: "rgba(0, 0, 0, 0)",
    touchCallout: "none",
    contentZooming: "none"
  }}
  dragPlaceholder={{
    enabled: false,
    duration: 300,
    easing: "ease",
    createElement: null,
    onCreate: null,
    onRemove: null
  }}

  {/* Classnames */}
  containerClass={"muuri"}
  itemClass={"muuri-item"}
  itemVisibleClass={"muuri-item-shown"}
  itemHiddenClass={"muuri-item-hidden"}
  itemPositioningClass={"muuri-item-positioning"}
  itemDraggingClass={"muuri-item-dragging"}
  itemReleasingClass={"muuri-item-releasing"}
  itemPlaceholderClass={"muuri-item-placeholder"}
/>
```

You can modify the default options easily:

```javascript
MuuriComponent.defaultOptions.showDuration = 400;
MuuriComponent.defaultOptions.dragSortPredicate.action = 'swap';
```

* [showDuration](#showduration)
* [showEasing](#showeasing)
* [hideDuration](#hideduration)
* [hideEasing](#hideeasing)
* [visibleStyles](#visiblestyles)
* [hiddenStyles](#hiddenstyles)
* [layout](#layout)
* [layoutOnResize](#layoutonresize)
* [layoutOnInit](#layoutoninit)
* [layoutDuration](#layoutduration)
* [layoutEasing](#layouteasing)
* [dragEnabled](#dragenabled)
* [dragContainer](#dragcontainer)
* [dragStartPredicate](#dragstartpredicate)
* [dragAxis](#dragaxis)
* [dragSort](#dragsort)
* [dragSortHeuristics](#dragsortheuristics)
* [dragSortPredicate](#dragsortpredicate)
* [dragReleaseDuration](#dragreleaseduration)
* [dragReleaseEasing](#dragreleaseeasing)
* [dragCssProps](#dragcssprops)
* [dragPlaceholder](#dragplaceholder)
* [containerClass](#containerclass)
* [itemClass](#itemclass)
* [itemVisibleClass](#itemvisibleclass)
* [itemHiddenClass](#itemhiddenclass)
* [itemPositioningClass](#itempositioningclass)
* [itemDraggingClass](#itemdraggingclass)
* [itemReleasingClass](#itemreleasingclass)
* [itemPlaceholderClass](#itemplaceholderclass)

#### showDuration

Show animation duration in milliseconds. Set to `0` to disable show animation.

* Default value: `300`.
* Accepted types: number.

```javascript
<MuuriComponent
  showDuration={600}
/>
```

#### showEasing

Show animation easing. Accepts any valid [Animation easing](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing) value.

* Default value: `'ease'`.
* Accepted types: string.

```javascript
<MuuriComponent
  showEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"}
/>
```

#### hideDuration

Hide animation duration in milliseconds. Set to `0` to disable hide animation.

* Default value: `300`.
* Accepted types: number.

```javascript
<MuuriComponent
  hideDuration={600}
/>
```

#### hideEasing

Hide animation easing. Accepts any valid [Animation easing](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing) value.

* Default value: `'ease'`.
* Accepted types: string.

```javascript
<MuuriComponent
  hideEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"}
/>
```

#### visibleStyles

The styles that will be applied to all visible items. These styles are also used for the show/hide animations which means that you have to have the same style properties in visibleStyles and hiddenStyles options. Be sure to define all style properties camel cased.

* Default value: `{opacity: 1, transform: 'scale(1)'}`.
* Accepted types: object.

```javascript
<MuuriComponent
  visibleStyles={{
    opacity: 1,
    transform: "rotate(45deg)"
  }}
  hiddenStyles={{
    opacity: 0,
    transform: "rotate(-45deg)"
  }}
/>
```

#### hiddenStyles

The styles that will be applied to all hidden items. These styles are also used for the show/hide animations which means that you have to have the same style properties in visibleStyles and hiddenStyles options. Be sure to define all style properties camel cased.

* Default value: `{opacity: 0, transform: "scale(0.5)"}`.
* Accepted types: object.

```javascript
<MuuriComponent
  visibleStyles={{
    opacity: 1,
    transform: "rotate(45deg)"
  }}
  hiddenStyles={{
    opacity: 0,
    transform: "rotate(-45deg)"
  }}
/>
```

#### layout

Define how the items will be laid out. Muuri ships with a configurable layout algorithm which is used by default. It's pretty flexible and suitable for most common situations (lists, grids and even bin packed grids). If that does not fit the bill you can always provide your own layout algorithm (it's not as scary as it sounds).

* Default value: `{fillGaps: false, horizontal: false, alignRight: false, alignBottom: false}`.
* Accepted types: function, object.

**Provide an _object_ to configure the default layout algorithm with the following properties**

* **fillGaps**&mdash;&nbsp; *boolean*
  * Default value: `false`.
  * When `true` the algorithm goes through every item in order and places each item to the first available free slot, even if the slot happens to be visually *before* the previous element's slot. Practically this means that the items might not end up visually in order, but there will be less gaps in the grid. By default this option is `false` which basically means that the following condition will be always true when calculating the layout (assuming `alignRight` and `alignBottom` are `false`): `nextItem.top > prevItem.top || (nextItem.top === prevItem.top && nextItem.left > prevItem.left)`. This also means that the items will be visually in order.
* **horizontal**&mdash;&nbsp; *boolean*
  * Default value: `false`.
  *  When `true` the grid works in landscape mode (grid expands to the right). Use for horizontally scrolling sites. When `false` the grid works in "portrait" mode and expands downwards.
* **alignRight**&mdash;&nbsp; *boolean*
  * Default value: `false`.
  * When `true` the items are aligned from right to left.
* **alignBottom**&mdash;&nbsp; *boolean*
  * Default value: `false`.
  * When `true` the items are aligned from the bottom up.
* **rounding**&mdash;&nbsp; *boolean*
  * Default value: `true`.
  * When `true` the dimensions of the items will be automatically rounded for the layout calculations using `Math.round()`. Set to `false` to use accurate dimensions. In practice you would want disable this if you are using relative dimension values for items (%, em, rem, etc.). If you have defined item dimensions with pixel values (px) it is recommended that you leave this on.

```javascript
// Customize the default layout algorithm.
<MuuriComponent
  layout={{
    fillGaps: true,
    horizontal: true,
    alignRight: true,
    alignBottom: true,
    rounding: false
  }}
/>
```

**Provide a _function_ to use a custom layout algorithm**

When you provide a custom layout function Muuri calls it whenever calculation of layout is necessary. Before calling the layout function Muuri always calculates the current width and height of the grid's container element and also creates an array of all the items that are part of the layout currently (all _active_ items).

* `customLayout( items, gridWidth, gridHeight )`
  * **items**&mdash;&nbsp; *array*
    * Array of `Muuri.Item` instances.
  * **gridWidth**&mdash;&nbsp; *number*
    * Current width of the grid's container element.
  * **gridHeight**&mdash;&nbsp; *number*
    * Current height of the grid's container element.

The layout function's job is using this data, which is provided to the layout function as arguments (as detailed above), and calculating position for each item in the array.

The layout function should _always_ return an object with following properties:

* **slots**&mdash;&nbsp; *array*
  * Array of the item positions (numbers). E.g. if the items were `[a, b]` this should be `[aLeft, aTop, bLeft, bTop]`. You have to calculate the `left` and `top` position for each item in the provided _items_ array in the same order the items are provided.
* **width**&mdash;&nbsp; *number*
  * The width of the grid.
* **height**&mdash;&nbsp; *number*
  * The height of the grid.
* **setWidth**&mdash;&nbsp; *boolean*
  * Should Muuri set the provided _width_ as the grid element's width?
* **setHeight**&mdash;&nbsp; *boolean*
  * Should Muuri set the provided _height_ as the grid element's height?

```javascript
// Build your own layout algorithm.
<MuuriComponent
  layout={function (items, gridWidth, gridHeight) {
    // The layout data object. Muuri will read this data and position the items
    // based on it.
    var layout = {
      // The layout's item slots (left/top coordinates).
      slots: [],
      // The layout's total width.
      width: 0,
      // The layout's total height.
      height: 0,
      // Should Muuri set the grid's width after layout?
      setWidth: true,
      // Should Muuri set the grid's height after layout?
      setHeight: true
    };

    // Calculate the slots.
    var item;
    var m;
    var x = 0;
    var y = 0;
    var w = 0;
    var h = 0;
    for (var i = 0; i < items.length; i++) {
      item = items[i];
      x += w;
      y += h;
      m = item.getMargin();
      w = item.getWidth() + m.left + m.right;
      h = item.getHeight() + m.top + m.bottom;
      layout.slots.push(x, y);
    }

    // Calculate the layout's total width and height. 
    layout.width = x + w;
    layout.height = y + h;

    return layout;
  }}
/>
```

#### layoutOnResize

Should Muuri automatically trigger `layout` method on window resize? Set to `false` to disable. When a number or `true` is provided Muuri will automatically lay out the items every time window is resized. The provided number (`true` is transformed to `0`) equals to the amount of time (in milliseconds) that is waited before items are laid out after each window resize event.

* Default value: `100`.
* Accepted types: boolean, number.

```javascript
// No layout on resize.
<MuuriComponent
  layoutOnResize={false}
/>
```

```javascript
// Layout on resize (instantly).
<MuuriComponent
  layoutOnResize={true}
/>
```

```javascript
// Layout on resize (with 200ms debounce).
<MuuriComponent
  layoutOnResize={200}
/>
```

#### layoutOnInit

Should Muuri trigger `layout` method automatically on init?

* Default value: `true`.
* Accepted types: boolean.

```javascript
<MuuriComponent
  layoutOnInit={false}
/>
```

#### layoutDuration

The duration for item's layout animation in milliseconds. Set to `0` to disable.

* Default value: `300`.
* Accepted types: number.

```javascript
<MuuriComponent
  layoutDuration={600}
/>
```

#### layoutEasing

The easing for item's layout animation. Accepts any valid [Animation easing](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing) value.

* Default value: `'ease'`.
* Accepted types: string.

```javascript
<MuuriComponent
  layoutEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"}
/>
```

#### dragEnabled

Should items be draggable?

* Default value: `false`.
* Accepted types: boolean.

```javascript
<MuuriComponent
  dragEnabled={true}
/>
```

#### dragContainer

The element the dragged item should be appended to for the duration of the drag. If set to `null` (which is also the default value) the grid's container element will be used.

* Default value: `null`.
* Accepted types: element, null.

```javascript
<MuuriComponent
  dragContainer={document.body}
/>
```

#### dragStartPredicate

A function that determines when the item should start to move when the item is being dragged. By default uses the built-in predicate which has some configurable options.

* Default value: `{distance: 0, delay: 0, handle: false}`.
* Accepted types: function, object.

If an object is provided the default sort predicate handler will be used. You can define the following properties:

* **distance**&mdash;&nbsp; *number*
  * Default value: `0`.
  * How many pixels must be dragged before the dragging starts.
* **delay**&mdash;&nbsp; *number*
  * Default value: `0`.
  * How long (in milliseconds) the user must drag before the dragging starts.
* **handle**&mdash;&nbsp; *string / boolean*
  * Default value: `false`.
  * The selector(s) which much match the event target element for the dragging to start. Note that if the event target element is a descendant of the handle element(s) it is also considered a match, which should be pretty useful in most scenarios.

If you provide a function you can totally customize the drag start logic. When the user starts to drag an item this predicate function will be called until you return `true` or `false`. If you return `true` the item will begin to move whenever the item is dragged. If you return `false` the item will not be moved at all. Note that after you have returned `true` or `false` this function will not be called until the item is released and dragged again.

The predicate function receives two arguments:

* **item**&mdash;&nbsp; *Muuri.Item*
  * The item that's being dragged.
* **event**&mdash;&nbsp; *object*
  * The drag event (Muuri.Dragger event).

```javascript
// Configure the default predicate
<MuuriComponent
  dragStartPredicate={{
    distance: 10,
    delay: 100,
    handle: ".foo, .bar"
  }}
/>
```

```javascript
// Provide your own predicate
<MuuriComponent
  dragStartPredicate={function (item, e) {
    // Start moving the item after the item has been dragged for one second.
    if (e.deltaTime > 1000) {
      return true;
    }
  }}
/>
```

```javascript
// Pro tip: provide your own predicate and fall back to the default predicate.
<MuuriComponent
  dragStartPredicate={function (item, e) {
    // If this is final event in the drag process, let's prepare the predicate
    // for the next round (do some resetting/teardown). The default predicate
    // always needs to be called during the final event if there's a chance it
    // has been triggered during the drag process because it does some necessary
    // state resetting.
    if (e.isFinal) {
      Muuri.ItemDrag.defaultStartPredicate(item, e);
      return;
    }

    // Prevent first item from being dragged. 
    if (grid.getItems().indexOf(item) === 0) {
      return false;
    }

    // For other items use the default drag start predicate.
    return Muuri.ItemDrag.defaultStartPredicate(item, e);
  }}
/>
```

#### dragAxis

Force items to be moved only vertically or horizontally when dragged. Set to `'x'` for horizontal movement and to `'y'` for vertical movement. By default items can be dragged both vertically and horizontally.

* Default value: `null`.
* Accepted types: string.
* Allowed values: `'x'`, `'y'`.

```javascript
// Move items only horizontally when dragged.
<MuuriComponent
  dragAxis={"x"}
/>
```

```javascript
// Move items only vertically when dragged.
<MuuriComponent
  dragAxis={"y"}
/>
```

#### dragSort

Should the items be sorted during drag? A simple boolean will do just fine here.

Alternatively you can do some advanced stuff and control within which MuuriComponents a specific item can be sorted and dragged into. To do that you need to provide the groupId of these MuuriComponents. See more [here](usage/reparenting)

* Default value: `true`.
* Accepted types: boolean, object.

```javascript
// Disable drag sorting.
<MuuriComponent
  dragSort={false}
/>
```

```js
<MuuriComponent
  dragSort={{ groupId: 'groupA' }}
/>
```

#### dragSortHeuristics

Defines various heuristics so that sorting during drag would be smoother and faster.

* Default value: `{sortInterval: 100, minDragDistance: 10, minBounceBackAngle: 1}`.
* Accepted types: object.

You can define the following properties:

* **sortInterval**&mdash;&nbsp; *number*
  * Default value: `100`.
  * Defines the amount of time the dragged item must be still before `dragSortPredicate` function is called.
* **minDragDistance**&mdash;&nbsp; *number*
  * Default value: `10`.
  * Defines how much (in pixels) the item must be dragged before `dragSortPredicate` can be called.
* **minBounceBackAngle**&mdash;&nbsp; *number*
  * Default value: `1`.
  * Defines the minimum angle (in radians) of the delta vector between the last movement vector and the current movement vector that is required for the dragged item to be allowed to be sorted to it's previous index. The problem this heuristic is trying to solve is the scenario where you drag an item over a much bigger item and the bigger item moves, but it's still overlapping the dragged item after repositioning. Now when you move the dragged item again another sort is triggered and the bigger item moves back to it's previous position. This bouncing back and forth can go on for quite a while and it looks quite erratic. The fix we do here is that, by default, we disallow an item to be moved back to it's previous position, unless it's drag direction changes enough. And what is enough? That's what you can define here. Note that this option works in tandem with `minDragDistance` and needs it to be set to `3` at minimum to be enabled at all.

```javascript
<MuuriComponent
  dragEnabled={true}
  dragSortHeuristics={{
    sortInterval: 10,
    minDragDistance: 5,
    minBounceBackAngle: Math.PI / 2
  }}
/>
```

#### dragSortPredicate

Defines the logic for the sort procedure during dragging an item.

* Default value: `{action: 'move', threshold: 50}`.
* Accepted types: function, object.

If an object is provided the default sort predicate handler will be used. You can define the following properties:
* **action**&mdash;&nbsp; *string*
  * Default value: `'move'`.
  * Allowed values: `'move'`, `'swap'`.
  * Should the dragged item be *moved* to the new position or should it *swap* places with the item it overlaps?
* **threshold**&mdash;&nbsp; *number*
  * Default value: `50`.
  * Allowed values: `1` - `100`.
  * How many percent the intersection area between the dragged item and the compared item should be from the maximum potential intersection area between the items before sorting is triggered.

Alternatively you can provide your own callback function where you can define your own custom sort logic. The callback function receives two arguments:

* **item**&mdash;&nbsp; *Muuri.Item*
  * The item that's being dragged.
* **event**&mdash;&nbsp; *object*
  * The drag event (Muuri.Dragger event).

The callback should return a *falsy* value if sorting should not occur. If, however, sorting should occur the callback should return an object containing the following properties:

* **index**&mdash;&nbsp; *number*
  * The index where the item should be moved to.
* **grid**&mdash;&nbsp; *Muuri*
  * The grid where the item should be moved to.
  * Defaults to the item's current grid.
  * Optional.
* **action**&mdash;&nbsp; *string*
  * The movement method.
  * Default value: `'move'`.
  * Allowed values: `'move'` or `'swap'`.
  * Optional.

```javascript
// Customize the default predicate.
<MuuriComponent
  dragSortPredicate={{
    threshold: 90,
    action: "swap"
  }}
/>
```

```javascript
// Provide your own predicate.
<MuuriComponent
  dragSortPredicate={function (item, e) {
    if (e.deltaTime < 1000) return false;
    return {
      index: Math.round(e.deltaTime / 1000) % 2 === 0 ? -1 : 0,
      action: "swap"
    };
  }}
/>
```

```javascript
// Pro tip: use the default predicate as fallback in your custom predicate.
<MuuriComponent
  dragSortPredicate={function (item, e) {
    if (item.classList.contains('no-sort')) return false;
    return Muuri.ItemDrag.defaultSortPredicate(item, {
      action: "swap",
      threshold: 75
    />
  }}
/>
```

#### dragReleaseDuration

The duration for item's drag release animation. Set to `0` to disable.

* Default value: `300`.
* Accepted types: number.

```javascript
<MuuriComponent
  dragReleaseDuration={600}
/>
```

#### dragReleaseEasing

The easing for item's drag release animation. Accepts any valid [Animation easing](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing) value.

* Default value: `'ease'`.
* Accepted types: string.

```javascript
<MuuriComponent
  dragReleaseEasing={"ease-out"}
/>
```

#### dragCssProps

Drag specific CSS properties that Muuri sets to the draggable item elements. Muuri automatically prefixes the properties before applying them to the element. `touchAction` property is required to be always defined, but the other properties are optional and can be omitted by setting their value to an empty string if you want to e.g. define them via CSS only.

* Default value: `{touchAction: 'none', userSelect: 'none', userDrag: 'none', tapHighlightColor: 'rgba(0, 0, 0, 0)', touchCallout: 'none', contentZooming: 'none'}`.
* Accepted types: object.

You can define the following properties:

* **touchAction**&mdash;&nbsp; *string*
  * Default value: `'none'`.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
* **userSelect**&mdash;&nbsp; *string*
  * Default value: `'none'`.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/user-select
  * Optional.
* **userDrag**&mdash;&nbsp; *string*
  * Default value: `'none'`.
  * http://help.dottoro.com/lcbixvwm.php
  * Optional.
* **tapHighlightColor**&mdash;&nbsp; *string*
  * Default value: `'rgba(0, 0, 0, 0)'`.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-tap-highlight-color
  * Optional.
* **touchCallout**&mdash;&nbsp; *string*
  * Default value: `'none'`.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-touch-callout
  * Optional.
* **contentZooming**&mdash;&nbsp; *string*
  * Default value: `'none'`.
  * https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-content-zooming
  * Optional.

```javascript
// Only set the required touch-action CSS property via the options if you for
// example want to set the other props via CSS instead.
<MuuriComponent
  dragEnabled={true}
  dragCssProps={{
    touchAction: 'pan-y',
    userSelect: '',
    userDrag: '',
    tapHighlightColor: '',
    touchCallout: '',
    contentZooming: ''
  }}
/>
```

#### dragPlaceholder

If you want a placeholder item to appear for the duration of an item's drag & drop procedure you can enable and configure it here.

* Default value: `{enabled: false, duration: 300, easing: 'ease', createElement: null, onCreate: null, onRemove: null}`.
* Accepted types: object.

You can define the following properties:

* **enabled**&mdash;&nbsp; *boolean*
  * Default value: `false`.
  * Is the placeholder enabled?
* **duration**&mdash;&nbsp; *number*
  * Default value: `300`.
  * The duration for placeholder's positioning animation. Set to `0` to disable.
* **easing**&mdash;&nbsp; *string*
  * Default value: `'ease'`.
  * The easing for placeholder's positioning animation. Accepts any valid [Animation easing](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing) value.
* **createElement**&mdash;&nbsp; *function / null*
  * Default value: `null`.
  * If defined, this method will be used to create the DOM element that is used for the placeholder. By default a new `div` element is created when a placeholder is summoned.
* **onCreate**&mdash;&nbsp; *function / null*
  * Default value: `null`.
  * An optional callback that will be called after a placeholder is created for an item.
* **onRemove**&mdash;&nbsp; *function / null*
  * Default value: `null`.
  * An optional callback that will be called after a placeholder is removed from the grid.

```javascript
// This example showcases how to pool placeholder elements
// for better performance and memory efficiency.
var phPool = [];
var phElem = document.createElement('div');

<MuuriComponent
  dragEnabled={true}
  dragPlaceholder={{
    enabled: true,
    duration: 400,
    easing: 'ease-out',
    createElement(item) {
      return phPool.pop() || phElem.cloneNode();
    },
    onCreate(item, element) {
      // If you want to do something after the
      // placeholder is fully created, here's
      // the place to do it.
    },
    onRemove (item, element) {
      phPool.push(element);
    }
  }}
/>
```

#### containerClass

Container element's class name.

* Default value: `'muuri'`.
* Accepted types: string.

```javascript
<MuuriComponent
  containerClass={"foo"}
/>
```

#### itemClass

Item element's class name.

* Default value: `'muuri-item'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemClass={"foo-item"}
/>
```

#### itemVisibleClass

Visible item's class name.

* Default value: `'muuri-item-shown'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemVisibleClass={"foo-item-shown"}
/>
```

#### itemHiddenClass

Hidden item's class name.

* Default value: `'muuri-item-hidden'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemHiddenClass={"foo-item-hidden"}
/>
```

#### itemPositioningClass

This class name will be added to the item element for the duration of positioning.

* Default value: `'muuri-item-positioning'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemPositioningClass={"foo-item-positioning"}
/>
```

#### itemDraggingClass

This class name will be added to the item element for the duration of drag.

* Default value: `'muuri-item-dragging'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemDraggingClass={foo-item-dragging"}
/>
```

#### itemReleasingClass

This class name will be added to the item element for the duration of release.

* Default value: `'muuri-item-releasing'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemReleasingClass={"foo-item-releasing"}
/>
```

#### itemPlaceholderClass

This class name will be added to the drag placeholder element.

* Default value: `'muuri-item-placeholder'`.
* Accepted types: string.

```javascript
<MuuriComponent
  itemPlaceholderClass={"foo-item-placeholder"}
/>
```